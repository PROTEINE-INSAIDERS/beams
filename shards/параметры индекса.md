## Выравнивание

Современны процессоры не страдают от доступа к невыровненной памяти 
(https://www.agner.org/optimize/blog/read.php?i=142&v=t) выравнивание может 
быть использовано только для сжатия указателей либо хранения в них дополнительной
информации.  
 
## Что хранится в узле

1. Тип вершины. Может отсутсвовать, если все вершины одного типа. В типе вершины можно 
кодировать доп. информацию о таблице смещений атрибутов переменной длинны.
2. Таблица нулей. Может отсутсвовать, если в схеме нет зануляемых атрибутов фиксированных размеров.
3. Атрибуты фиксированных размеров. 
4. Таблица смещений атрибутов переменных размеров.

### Формат записи таблицы смещений атрибутов переменных размеров

1. Смещение. Предназначено для хранения указателей на самотерминируемые списки. 0 - если список пуст.
Если используется тип вершины, в нём можно кодировать индивидуальный размер смещения.
2. Пара смешение - размер. 
Если используется тип вершины, в нём можно кодировать индивидуальный размер пары смещение-размер.

### Адаптивное увеличение размеров смещения

В процессе построения узла можно начинать с самых малых размеров смешение - размер. При добавлении
новых атрибутов переменного размера можно сначала переходить с к сжатым смещениям (и выравниванию данных
при размещении, хотя не факт, что имеет смысл применять эту стратегию на 8-битных смещениях), далее 
расширять смещения и размеры, генерируя новые схемы.

Нужно уметь ограничивать количество сгенерированных схем, т.к. их количество может расти 
экспоненциально от количества атрибутов переменной длинны.

Можно применять эвристику "несжатия". Если на каком-то этапе стало известно, что для хранения 
атрибута пришлось расширить смещение или размер, для всех следующих атрибутов следует использовать
не меньшие размеры смещений и размеров, т.к. выигрыш будет незначительным с учетом уже записанных данных.

## Указатели на вершины

Предлагается использовать 48-битные указатели:
2^48 = 281 474 976 710 656

При этом если выравнивать вершины по 4-байтной границе, 2 младших бита можно использовать 
для служебной информации - терминатор списка и указатель размерности. Указатель размерности
можно использовать для понижения размерности до 32-бит (31 с учетом терминатора списка, т.е. 
до 1 073 741 824 вершин в локальной шарде могут хранитья в 32-x битном формате).

Указатели на вершины можно группировать по шардам:
|shard_id(8)|edge(40)|edge(40)|edge(40)|shard_id(8)|..

При этом младший бит можно использовать как терминатор списка. Конец всего списка можно кодировать 
шардой 0 или 255. Имеет ли смысл при этом доплнительно сжимать вершины до 32-x бит (до 20% экономии)?   

## Дополнительные соображения

### Непосредственная аллокация

Метод непосредственной аллокации (когда мы не строим сериализованного представления индекса, 
а просто вызываем malloc для каждой вершины) может показаться соблазнительным, но, скорее всего
оверхед менеджера памяти будет неприемлемым. 

### Прямые указатели вместо смещений

Прямые указатели экономят одну операцию сложения, но указатель занимает 64 бита. Скорее всего, 
оно того не стоит.

### Хранение размера атрибута переменной длины

Размер следует хранить вместе с атрибутом, а не в таблице смещений. Это упростит реализацию 
десериализаторов (им нужно знать размер).

### Списки исходящих и входящих рёбер

Так как данные списки содержат смещения, их длина может зависеть только от количества элементов,
но не от значений. Иначе получается циклическая зависимость. То же самое с группировкой по 
шардам.  

#### Размерность смещения вершины

За исключением специального случая, когда большая часть смещений помещается в 32 бита и лишь 
небольшая в 48, все смещения имеет смысл хранить в одном формате. В случае применения сжатия 
возможно адресовать 16G памяти, либо 2 миллиарда вершин при фиксированном размере вершины.

### Размерность смещений или сколько вершин мы можем хранить в одной шарде

Даже если одна вершина занимает около 100 байт (а это всего 25 рёбер при смещении в 32 бита или 16 при 
использовании 48-битных смещений), 2^32 вершин займут 0.5 TB памяти. Не имеет смысла делать шарды, 
вмещающие более 2^32 вершин. Следовательно, можно использовать фиксированную адресацию: 
48 бит, из которых 16 - идентификатор шарда, 32 - номер вершины внутри шарда.

## Прототип 1

Цели:
- Простота
- Скорость
- Достаточный размер шарда для утилизации узла кластера
- Дружелюбность к кешу

### Принципы реализации

- Вершины хранятся отдельно от атрибутов и имеют фиксированные размеры. Таким образом можно адресовать
каждую вершину 16 битным индексом шарды и 32 битным индексом самой вершины посредством умножения индекса
вершины на её размер и добавлением базового адреса. Допускается хранение в файле вершин набора атрибутов
фиксированных размеров, но пока это можно не делать в пользу простоты.
- Каждая вершина представляет собой структуру из фиксированного числа доменов (16 бит - идентификатор 
домена, 48 бит - смещение внутри домена). Т.е. 64 бита на одну вершину.  Допускается использование 
нескольких доменов.
- Домен - хранилище атрибутов вершины. Набор входящих и исходящих рёбер также являются атрибутами. 
Их можно представить либо списками из 48-битных значений, либо сгруппировать по шардам и использовать 
32-х битные значения.

Задача:
Придумать формат хранения списка вершин с группировкой по шардам. 

Зачем?
Внутри шарда вершина адресуется 32-битами, вне - 48.

Варианты:
1. Перед каждой группой сохраняется её размер в формате VLQ. Минимум 1 байт.
2. 2^31 вершин внутри одной шарды, свободный бит используем как флаг терминатора  -- это оптимальный вариант.
3. Терминация списка 32-х битным нулём. -- это даже хуже, чем 1