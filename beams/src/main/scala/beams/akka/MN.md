Управление ресурсами.

Программа может создавать долгоживущие ресурсы (ноды) в процессе выполнения. 
Для облегчения управления их временем жизни можно использовать расширение 
синтаксиса ```def node[R](r: R): TaskR[Beam[Node, Any], Managed[Throwable, Node[R]]]```

Но оно не гарантирует, что при завершенни программы все созданные узлы будут 
остановлены. Сейчас для работы в кластерном режиме на каждом из узлов создаётся 
отдельный корневой актор для программы. Это позволяет гарантированно очистить 
все ресурсы при завершенни программы. Но это плохо ложится в концепцию кластера,
где ноды могут появляться и отваливаться в процессе работы. Это также не 
позволяет выполнять мониторинг кластера средствами beams. Требуется реализовать
такой подход, поддерживающий динамическое изменение структуры кластера в 
процессе выполнения программы и при этом гарантирующий освобождение ресурсов.

Возможные варианты реализации:
- В программе содержится список корневых узлов (на самом деле не удобно, этот 
список придётся постоянно сериализовывать и таскать с собой в каждом сообщении).
- Список корневых узлов поддерживается специальным актором-монитором (это уже 
гораздо лучше, потому что программа сможет работать вообще без такого монитора).

Если мы запускаемся на каком-либо корневом узле, как понять, что на этом узле 
для нашего процесса уже создан контейнер? Без контекстной информации скорее всего 
никак. Поэтому следует создавать NodeActor на всех корневых узлах и использовать
его для обработки всех запросов. Также он должен знать, что является корневым, 
и регистрировать CreateNode в мониторе (как вариант - эти знания есть у beam-а).